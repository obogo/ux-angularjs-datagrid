{"version":3,"sources":["ux-datagrid-iscroll.js"],"names":["exports","global","define","amd","module","ux","angular","factory","inst","refresh","options","mouseWheel","scrollbars","bounce","bindToWrapper","tap","interactiveScrollbars","deceleration","click","startY","scrollHistory","getCurrentScroll","values","scroll","myScroll","element","style","overflowY","result","log","IScroll","on","beforeScrollStart","onScrollEnd","_initEvents","scroller","getContent","scrollerStyle","scrollTo","iScroll","refeshRender","clearRefreshRender","unwatchRefreshRender","setInterval","onRefreshRender","stop","clearTimeout","intv","scrolling","dispatch","datagrid","events","ON_SCROLL_START","y","setTimeout","scrollEnd","updateDelay","originalScrollModel","onScrollingStop","clearInterval","h","offsetHeight","getContentHeight","onUpdateScroll","event","forceValue","value","undefined","lastY","speed","absSpeed","Math","abs","setScroll","scrollPercent","toFixed","fireOnScroll","isIOS","throwError","scrollToIntv","unwatchSetup","logWrapper","scrollModel","scope","$on","ON_READY","removeScrollListener","unwatchers","push","ON_AFTER_HEIGHTS_UPDATED_RENDER","getScroll","waitForStop","immediately","scrollTop","capScrollValue","scrollToIndex","scrollToItem","scrollIntoView","scrollToBottom","getViewportHeight","destroy","this"],"mappings":"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","file":"ux-datagrid-iscroll.min.js","sourcesContent":["/*!\n* ux-angularjs-datagrid v.1.6.3\n* (c) 2017, Obogo\n* https://github.com/obogo/ux-angularjs-datagrid\n* License: MIT.\n*/\n(function (exports, global) {\nif (typeof define === \"function\" && define.amd) {\n  define(exports);\n} else if (typeof module !== \"undefined\" && module.exports) {\n  module.exports = exports;\n} else {\n  global.ux = exports;\n}\n\n/**\n * ##<a name=\"iScrollAddon\">iScrollAddon</a>##\n * This requires [iscroll.js](https://github.com/cubiq/iscroll) to work.\n */\nangular.module(\"ux\").factory(\"iScrollAddon\", function() {\n    return [ \"inst\", function(inst) {\n        // This is only needed for IOS devices. Android devices work fine without it.\n        if (!exports.datagrid.isIOS) {\n            return;\n        }\n        if (!IScroll) {\n            inst.throwError(\"IScroll (https://github.com/cubiq/iscroll) is required to use the iScrollAddon.\");\n        }\n        var result = exports.logWrapper(\"iScrollAddon\", {}, \"purple\", inst), scrolling = false, intv, myScroll, originalScrollModel = inst.scrollModel, unwatchRefreshRender, scrollToIntv, unwatchSetup, lastY = 0;\n        unwatchSetup = inst.scope.$on(exports.datagrid.events.ON_READY, function() {\n            originalScrollModel.removeScrollListener();\n            unwatchSetup();\n        });\n        inst.unwatchers.push(inst.scope.$on(exports.datagrid.events.ON_AFTER_HEIGHTS_UPDATED_RENDER, refresh));\n        function refresh() {\n            var options = {\n                mouseWheel: true,\n                scrollbars: true,\n                bounce: true,\n                bindToWrapper: true,\n                tap: true,\n                interactiveScrollbars: true,\n                deceleration: .005,\n                click: true,\n                startY: -(inst.scrollHistory && inst.scrollHistory.getCurrentScroll() || inst.values.scroll || 0)\n            };\n            if (!myScroll) {\n                inst.element[0].style.overflowY = \"hidden\";\n                //TODO: these options need to be passed in.\n                result.log(\"IScroll Init at startY %s\", options.startY);\n                myScroll = new IScroll(inst.element[0], options);\n                myScroll.on(\"beforeScrollStart\", beforeScrollStart);\n                myScroll.on(\"scrollStart\", beforeScrollStart);\n                myScroll.on(\"scrollEnd\", onScrollEnd);\n            }\n            myScroll._initEvents(true);\n            myScroll.scroller = inst.getContent()[0];\n            myScroll.scrollerStyle = myScroll.scroller.style;\n            myScroll._initEvents();\n            myScroll.scrollTo(0, options.startY);\n            // update the transform.\n            result.iScroll = myScroll;\n            refeshRender();\n        }\n        function refeshRender() {\n            // iScroll always needs to wait till the next frame for offsetHeight to update before refresh.\n            clearRefreshRender();\n            unwatchRefreshRender = setInterval(onRefreshRender, 100);\n        }\n        function stop() {\n            clearTimeout(intv);\n        }\n        function beforeScrollStart() {\n            stop();\n            scrolling = true;\n            inst.dispatch(exports.datagrid.events.ON_SCROLL_START, -myScroll.y);\n        }\n        function onScrollEnd() {\n            stop();\n            intv = setTimeout(scrollEnd, inst.options.updateDelay);\n        }\n        function scrollEnd() {\n            inst.values.scroll = -myScroll.y;\n            originalScrollModel.onScrollingStop();\n            scrolling = false;\n        }\n        function clearRefreshRender() {\n            clearInterval(unwatchRefreshRender);\n        }\n        function onRefreshRender() {\n            var h;\n            if (!inst.element) {\n                clearRefreshRender();\n            } else if (h = inst.element[0].offsetHeight) {\n                clearRefreshRender();\n                result.log(\"\\trefresh iscroll height:%s/%s\", h, inst.getContentHeight());\n                myScroll.refresh();\n            }\n        }\n        function onUpdateScroll(event, forceValue) {\n            var value = forceValue !== undefined ? -forceValue : myScroll.y;\n            if (scrolling && value !== lastY) {\n                inst.values.speed = value - lastY;\n                inst.values.absSpeed = Math.abs(inst.values.speed);\n                result.setScroll(-value);\n                lastY = value;\n                inst.values.scrollPercent = (inst.values.scroll / inst.getContentHeight() * 100).toFixed(2);\n                result.fireOnScroll();\n            }\n        }\n        result.getScroll = function() {\n            return myScroll && myScroll.y || 0;\n        };\n        result.setScroll = function(value) {\n            result.log(\"setScroll %s\", value);\n            inst.values.scroll = value;\n        };\n        result.waitForStop = originalScrollModel.waitForStop;\n        result.scrollTo = function(value, immediately) {\n            result.log(\"scrollTo %s\", value);\n            if (inst.element[0].scrollTop) {\n                inst.element[0].scrollTop = 0;\n            }\n            if (!myScroll) {\n                refresh();\n            }\n            value = originalScrollModel.capScrollValue(value);\n            myScroll.scrollTo(0, -value, immediately ? 0 : 200);\n            clearTimeout(scrollToIntv);\n            if (immediately) {\n                if (inst.values.scroll || value) {\n                    scrolling = true;\n                    result.onUpdateScroll(null, value);\n                    scrolling = false;\n                    result.onScrollingStop();\n                }\n            } else {\n                scrollToIntv = setTimeout(function() {\n                    result.onScrollingStop();\n                }, 200);\n            }\n        };\n        result.scrollToIndex = originalScrollModel.scrollToIndex;\n        result.scrollToItem = originalScrollModel.scrollToItem;\n        result.scrollIntoView = originalScrollModel.scrollIntoView;\n        result.scrollToBottom = function(immediately) {\n            var value = inst.getContentHeight() - inst.getViewportHeight();\n            myScroll.scrollTo(0, -value, immediately ? 0 : 200);\n        };\n        result.onScrollingStop = originalScrollModel.onScrollingStop;\n        result.onUpdateScroll = onUpdateScroll;\n        result.fireOnScroll = originalScrollModel.fireOnScroll;\n        inst.unwatchers.push(inst.scope.$on(exports.datagrid.events.ON_AFTER_HEIGHTS_UPDATED_RENDER, function() {\n            inst.element[0].scrollTop = 0;\n            if (myScroll) {\n                onRefreshRender();\n            }\n        }));\n        result.destroy = function destroy() {\n            unwatchSetup();\n            clearTimeout(scrollToIntv);\n            stop();\n            originalScrollModel.destroy();\n            if (myScroll) {\n                myScroll.destroy();\n            }\n        };\n        inst.scrollModel = result;\n        return result;\n    } ];\n});\n}(this.ux = this.ux || {}, function() {return this;}()));\n"]}